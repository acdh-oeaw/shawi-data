<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml"
	schematypens="http://purl.oclc.org/dsdl/schematron"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:s="http://purl.oclc.org/dsdl/schematron">
    <teiHeader>
        <fileDesc>
            <titleStmt>
                <title>Shawi Dictionary Schema</title>
                <author>Charly Mörth</author>
                <author>Daniel Schopper</author>
                <author>Michaela Rausch-Supola</author>
                <author>Veronika Engler</author>
            </titleStmt>
            <publicationStmt>
                <publisher>Austrian Centre for Digital Humanities and Cultural Heritage</publisher>
                <date>2024</date>
            </publicationStmt>
            <sourceDesc>
                <p>This ODD is a customization of TEI Lex-0, adapted for the needs of the
                    SHAWI-Project of the ACDH-CH.</p>
            </sourceDesc>
        </fileDesc>
        <revisionDesc>
            <change status="draft" when="2024-03-01">set up ODD</change>
        </revisionDesc>
    </teiHeader>
    <text>
        <front>
            <argument>
                <p>This TEI customization fits the needs of the SHAWI-Project while conforming with
                    the baseline schema of all dictionaries created at the ACDH-CH.</p>
            </argument>
        </front>
        <body>
            <head>SHAWI </head>
            <div>
                <head>General Remarks</head>
                <p>This is the ODD for the "Shawi" dictionary, created in the project "The
                    Shawi-type Arabic dialects spoken in South-eastern Anatolia and the Middle
                    Euphrates region" (FWF P 33574), led by Stephan Próchazka (University of Viena,
                    Department for Near Estern studies) and Charly Mörth (Austrian Academy of
                    Sciences, Austrian Centre for Digial Humanities). In Arabic dialectology, the
                    term “Shawi-Arabic” refers to a bundle of closely related dialects spoken by
                        Šawāya<note place="bottom">
                        <p>The term Šawāya is an exonym and sometimes even regarded as mildly
                            pejorative by the so named people themselves. Thus, in this application,
                            the term is understood in a purely areal linguistic sense (see next
                            paragraph) as it has been well-established in Arabic dialectology for
                            many decades  (cf. Behnstedt 2000:424, Herin &amp; Younes 2019, Jastrow
                            1997, Lentin 2013:152-155).</p>
                    </note> (plural of Šāwī), sheep and goat herding semi-nomadic tribes in various
                    regions of the Fertile Crescent, esp. Syria, Turkey, northern Lebanon, northern
                    Israel, and Jordan.</p>
                <p>The dictionary is a customization of <ref
                        target="https://dariah-eric.github.io/lexicalresources/pages/TEILex0/TEILex0.html"
                        >TEI Lex-0</ref> through the <ref
                        target="https://github.com/acdh-oeaw/generic-dict-schema/">ACDH generic dict
                        schema</ref> which defines a framework for dictionaries created at the ACDH,
                    namely the ones to be created in the context of VICAV - the Vienna Corpus of
                    Arabic Varieties. Please refer to the ODD of the generic dict schema for more
                    information. This ODD describes and documents where the Shawi dictionary differs
                    from this schema.</p>
            </div>
            <div>
                <head>Entries</head>
                
                <p>The <name>generic dict schema</name> introduces <tag>entry type="multiWordUnit</tag> in order to ensure backward compatability with the
                    legacy encoding of VICAV dictionaries. Since the Shawi dictionary should follow TEI Lex-0 more closely,
                    this is overridden by the values proposed by TEI Lex-0.<specList>
                        <specDesc key="entry"/>
                    </specList></p>
            </div>
            <div>
                <head>Diatopic information</head>
                <p>Given the geographic distribution of the varities described in this dictionary,
                    we aim at documenting the provenance of lemmas (<tag>form type="lemma"</tag>),
                    variants (<tag>form type="variant"</tag>) and inflected forms (<tag>form
                        type="inflected"</tag>). We thus require <tag>usg type="geographic</tag>
                    inside of these elements (in contrast to the <name>generic dict schema</name>
                    where this is no requirement).</p>
                <p>
                    <specList>
                        <specDesc key="form"/>
                    </specList>
                </p>
            </div>
            <div>
                <head>Subcategorization</head>
                <p>Certain grammatical features are further subcategorized. This is encoded as <gi>gram</gi> elements with <att>type</att>=<val>subc</val>. Conceptually, certain values of these gram elements are tied to other gram values (e.g. subc="pluralNoun" implies pos="noun"). At the moment, we cannot express this relation in the encoding, by enforce it via schematron rules.</p>
                <p>Possible combinations are:</p>
                <table>
                    <row role="label">
                        <cell><val>pos</val> value</cell>
                        <cell><val>subc</val> value</cell>
                    </row>
                    <row><cell>noun</cell><cell>toponym​</cell></row>
                    <row><cell>noun</cell><cell>collectiveNoun​</cell></row>
                    <row><cell>noun</cell><cell>pluralNoun​</cell></row>
                    <row><cell>noun</cell><cell>unitNoun​</cell></row>
                    <row><cell>noun</cell><cell>diminutiveNoun​</cell></row>
                    <row><cell>numeral</cell><cell>fraction​</cell></row>
                    <row><cell>numeral</cell><cell>ordinal​</cell></row>
                </table>
            </div>
            <div>
                <head>Sources for entry parts or examples</head>
                <p>Each part of an entry can indicate the source its information is based on. In order to be able to specifically reference exact page numbers instead of whole publications, we include a <gi>listBibl</gi> at the end of each entry or example:</p>
                <egXML xmlns="http://www.tei-c.org/ns/Examples" valid="feasible">
                    <entry>
                        <form source="#d1e299557" type="lemma">
                            <orth>zarub</orth>
                        </form>
                        <!-- ... -->
                        <listBibl type="literature">
                            <bibl xml:id="d1e2995">
                                <title ref="zot:Lentin2013"/>
                                <biblScope unit="page">p.159</biblScope>
                            </bibl>
                        </listBibl>
                    </entry>
                    
                </egXML>
            </div>
            <div>
                <head>Part 2: Formal Specification</head>

                <!--<schemaSpec ident="shawi"
                    source="https://raw.githubusercontent.com/acdh-oeaw/generic-dict-schema/main/schema/tmp/acdh-ch-dicts.compiled.odd">-->
                <schemaSpec ident="shawi"
                    source="file:///home/danielschopper/data/generic-dict-schema/schema/acdh-ch-dicts.compiled.odd">

                    <!-- We copy all modules from Generic dicts  -->
                    <moduleRef key="derived-module-TEILex0"/>
                    <moduleRef key="analysis"/>
                    <moduleRef key="core" except="ptr q interpretation lb mentioned"/>
                    <moduleRef key="dictionaries"/>
                    <moduleRef key="figures"/>
                    <moduleRef key="gaiji"/>
                    <moduleRef key="header"/>
                    <moduleRef key="linking"/>
                    <moduleRef key="namesdates"/>
                    <moduleRef key="tei"/>
                    <moduleRef key="textstructure"/>
                    <moduleRef key="transcr"/>
                    <moduleRef key="iso-fs"/>
                    <!-- DS ref[@type="entry"] is currently not used. -->
                    <!--  <elementSpec ident="ref" mode="change" module="core">
                        <constraintSpec ident="quote-ref" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:ref[@type='entry']">
                                    <s:assert test="parent::tei:quote">A ref type entry has to be
                                        child of quote</s:assert>
                                    <s:let name="entryIDs" value="//tei:entry/@xml:id"/>
                                    <s:assert
                                        test="some $entryID in $entryIDs satisfies $entryID = substring-after(@target, '#')"
                                        >The target attribute of a ref element in quote (<s:value-of
                                            select="@target"/>) must match the xml:id of an
                                        entry</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>-->


                    <elementSpec ident="val" mode="delete"/>
                    
                    <classSpec type="atts" ident="att.measurement" mode="delete"/>

                    <elementSpec ident="gramGrp" mode="change" module="dictionaries">
                        <content>
                            <elementRef key="model.gramPart" minOccurs="1" maxOccurs="unbounded"/>
                        </content>
                        <constraintSpec ident="gram-roots" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:gramGrp">
                                    <s:assert test="not(tei:gram[@type='synRoot']) = not(tei:gram[@type='diaRoot'])">if there is a gram type 'diaRoot', there has to be a gram type 'synRoot' in the same gramGrp, and vice versa</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>

                    <elementSpec ident="gram" mode="change" module="dictionaries">
                        <constraintSpec ident="gram-constraints" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:gram[@type = 'morphPattern']">
                                    <s:assert test="parent::tei:gramGrp/parent::tei:form[@type]">a
                                        gram type morphPattern must be a direct child of a gramGrp
                                        and a direct grandchild of a form with a type
                                        attribute</s:assert>
                                </s:rule>
                                <s:rule context="tei:gram[@type = 'polarity']">
                                    <s:assert test="normalize-space(.) = 'negative'">'gram' elements with type 'polarity' can only have the value 'negative'</s:assert>
                                </s:rule>
                                <s:rule context="tei:gram[@type = 'degree']">
                                    <s:assert test="normalize-space(.) = 'elative'">'gram' elements with type 'degree' can only have the value 'elative'</s:assert>
                                </s:rule>
                                <s:rule context="tei:gram[@type = 'subc']">
                                    <s:assert test="not(normalize-space(.) = 'elative')">'gram' elements with type 'subc' can not have the value 'elative'</s:assert>
                                    <s:assert test="normalize-space(.) = ('toponym','collectiveNoun','pluralNoun','unitNoun', 'diminutiveNoun', 'fraction','ordinal​')">unexpected value "<s:value-of select="."/>" in gram[@type='subc'] is expected to be 'toponym','collectiveNoun','pluralNoun','unitNoun', 'diminutiveNoun', 'fraction','ordinal​'</s:assert>                                    
                                </s:rule>
                                <s:rule context="tei:gram[@type = 'subc'][contains(normalize-space(.),'noun')]">
                                    <s:assert test="../tei:gram[@type='pos']='noun'">gram[@type='subc'] is not expected in combination with gram[@type='pos']='<s:value-of select="../tei:gram[@type='pos']"/>' (expected: "noun")</s:assert>
                                </s:rule>
                                <s:rule context="tei:gram[@type = 'subc'][normalize-space(.)=('fraction','ordinal')]">
                                    <s:assert test="../tei:gram[@type='pos']='numeral'">gram[@type='subc'] = fraction or ordinal is not expected in combination with gram[@type='pos']='<s:value-of select="../tei:gram[@type='pos']"/>' (expected: "numeral")</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>    
                    </elementSpec>
                    
                    <classSpec type="atts" ident="shawi.gramTypes" mode="add">
                        <attList>
                            <attDef ident="type" mode="add">
                                <valList type="closed">
                                    <valItem ident="case"/>
                                </valList>
                            </attDef>
                        </attList>
                    </classSpec>

                    <elementSpec ident="form" mode="change" module="dictionaries">
                        <constraintSpec ident="compoundOrth" scheme="schematron">
                            <constraint>
                                <s:rule
                                    context="tei:form[@type='lemma']/tei:orth[contains(., ' ') or matches(., '\w+-\w+')]">
                                    <s:assert test="parent::tei:form[@subtype = 'compound']">a form
                                        type lemma with an orth that contains a space or a hyphen
                                        (not at the beginning or end of a string) has to have a
                                        subtype compound</s:assert>
                                </s:rule>
                                <s:rule
                                    context="tei:form[@type=('lemma','variant','inflected')]">
                                    <s:assert test="tei:usg[@type='geographic']">lemmas, inflected forms and variants must inlcude usg[@type='geographic']</s:assert>
                                </s:rule>
                                <s:rule context="tei:form[@subtype='compound']">
                                    <s:assert
                                        test="tei:orth[contains(., ' ') or matches(., '\w+-\w+')]">a
                                        form with subtype compound has to have an orth child that
                                        contains a space or a hyphen (not at the beginning or end of
                                        a string)</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                        <constraintSpec ident="noType" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:form[not(@type)]">
                                    <s:assert test="parent::tei:cit[@type=('translationEquivalent','etymon')]">form elements without @type must only occur in translationEquivalents</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                        <!--<!-\- given that generic-dict-schema introduces form/@type="multiWordUnit" for backwards-compatability, we override this here according to TEI Lex-0. -\->
                        <attList>
                            <attDef ident="type" mode="replace" usage="opt">
                                <valList type="closed">
                                    <valItem ident="lemma">
                                        <desc>the headword of a lemma entry</desc>
                                    </valItem>
                                    <valItem ident="inflected">
                                        <desc>inflected form</desc>
                                    </valItem>
                                    <valItem ident="variant">
                                        <desc>A variant form of the lemma or inflected forms. The
                                            more frequent variant should precede less frequent ones.
                                        </desc>
                                    </valItem>
                                </valList>
                            </attDef>
                        </attList>-->
                    </elementSpec>

                    <elementSpec ident="biblScope" mode="change" module="dictionaries">
                        <constraintSpec ident="biblScope-context" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:biblScope">
                                    <s:assert test="matches(., '^p\.\s?\d')">Missing or misspelled
                                        page number</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>

                    <elementSpec ident="entry" mode="change" module="dictionaries">
                        <constraintSpec ident="formSourceCheck" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:form[@source]">
                                    <s:let name="sourceIDs" value="tokenize(@source,' ')"/>
                                    <s:let name="biblID"
                                        value="following-sibling::tei:listBibl/tei:bibl/@xml:id | parent::tei:form/following-sibling::tei:listBibl/tei:bibl/@xml:id | parent::tei:form/parent::tei:form/following-sibling::tei:listBibl/tei:bibl/@xml:id"/>
                                    <s:assert
                                        test="every $sourceID in $sourceIDs satisfies substring-after($sourceID, '#') = $biblID"
                                        >If a form element has a source attribute there must be a
                                        corresponding bibl element in listBibl ("<s:value-of
                                            select="$biblID"/>")</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                        <constraintSpec ident="senseSourceCheck" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:sense[@source]">
                                    <s:let name="sourceIDs" value="tokenize(@source,' ')"/>
                                    <s:let name="biblID"
                                        value="following-sibling::tei:listBibl/tei:bibl/@xml:id"/>
                                    <s:assert
                                        test="every $sourceID in $sourceIDs satisfies substring-after($sourceID, '#') = $biblID"
                                        >If a sense element has a source attribute there must be a
                                        corresponding bibl element in listBibl ("<s:value-of
                                            select="$biblID"/>")</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>

                    <elementSpec ident="name" mode="change" module="core">
                        <constraintSpec ident="name-not-empty" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:name">
                                    <s:assert test="normalize-space(.) != ''">1: the type attribute
                                        of a name element must not be empty</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                        <attList>
                            <attDef ident="type" mode="replace" usage="req">
                                <valList type="closed">
                                    <valItem ident="place">
                                        <desc>TODO description missing</desc>
                                    </valItem>
                                    <valItem ident="tribe">
                                        <desc>TODO description missing</desc>
                                    </valItem>
                                </valList>
                            </attDef>
                        </attList>
                    </elementSpec>

                  

                </schemaSpec>
            </div>
        </body>
    </text>
</TEI>
