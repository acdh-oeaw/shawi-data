<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml"
	schematypens="http://purl.oclc.org/dsdl/schematron"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:s="http://purl.oclc.org/dsdl/schematron">
    <teiHeader>
        <fileDesc>
            <titleStmt>
                <title>Shawi Dictionary Schema</title>
                <author><name>Charly Mörth</name></author>
                <author><name>Daniel Schopper</name></author>
                <author><name>Michaela Rausch-Supola</name></author>
                <author><name>Veronika Engler</name></author>
            </titleStmt>
            <publicationStmt>
                <publisher>Austrian Centre for Digital Humanities and Cultural Heritage</publisher>
                <date>2024</date>
            </publicationStmt>
            <sourceDesc>
                <p>This ODD is a customization of TEI Lex-0, adapted for the needs of the
                    SHAWI-Project of the ACDH.</p>
            </sourceDesc>
        </fileDesc>
        <revisionDesc>
            <change status="draft" when="2024-03-01">set up ODD</change>
        </revisionDesc>
    </teiHeader>
    <text>
        <front>
            <argument>
                <p>This TEI customization fits the needs of the SHAWI-Project while conforming with
                    the baseline schema of all dictionaries created at the ACDH.</p>
            </argument>
        </front>
        <body>
            <head>SHAWI </head>
            <div>
                <head>General Remarks</head>
                <p>This is the ODD for the "Shawi" dictionary, created in the project "The
                    Shawi-type Arabic dialects spoken in South-eastern Anatolia and the Middle
                    Euphrates region" (FWF P 33574), led by Stephan Próchazka (University of Vienna,
                    Department of Near Estern Studies) and Charly Mörth (Austrian Academy of
                    Sciences, Austrian Centre for Digial Humanities). In Arabic dialectology, the
                    term “Shawi-Arabic” refers to a bundle of closely related dialects spoken by
                        Šawāya<note place="bottom">
                        <p>The term Šawāya is an exonym and sometimes even regarded as mildly
                            pejorative by the so named people themselves. Thus, in this application,
                            the term is understood in a purely areal linguistic sense (see next
                            paragraph) as it has been well-established in Arabic dialectology for
                            many decades  (cf. Behnstedt 2000:424, Herin &amp; Younes 2019, Jastrow
                            1997, Lentin 2013:152-155).</p>
                    </note> (plural of Šāwī), sheep and goat herding semi-nomadic tribes in various
                    regions of the Fertile Crescent, esp. Syria, Turkey, northern Lebanon, northern
                    Israel, and Jordan.</p>
                <p>The dictionary is a customization of <ref
                        target="https://dariah-eric.github.io/lexicalresources/pages/TEILex0/TEILex0.html"
                        >TEI Lex-0</ref> through the <ref
                        target="https://github.com/acdh-oeaw/generic-dict-schema/">ACDH generic dict
                        schema</ref> which defines a framework for dictionaries created at the ACDH,
                    namely the ones to be created in the context of VICAV - the Vienna Corpus of
                    Arabic Varieties. Please refer to the ODD of the generic dict schema for more
                    information. This ODD describes and documents where the Shawi dictionary differs
                    from this schema.</p>
            </div>
            <div>
                <head>Dictionary Entries</head>
                <p>Entries in the Shawi dictionary follow the Lex-0 model. Accordingly, dictionary entries describing
                    multi-word-units are encoded as <tag>entry type="main" subtype="compound"</tag> (see <ref target="https://dariah-eric.github.io/lexicalresources/pages/TEILex0/TEILex0.html#index.xml-body.1_div.4_div.6">Section 4.6. Multiword expressions</ref>).</p>
                <p>The <name>generic dict schema</name> introduces <tag>entry
                    type="multiWordUnit</tag> for encoding MWUs in order to ensure backwards compatability with the legacy encoding of VICAV dictionaries. Since the Shawi
                    dictionary should follow TEI Lex-0 more closely, this is overridden in the Shawi Dictionary ODD again. We relocate the distinction onto the <tag>form</tag> level.</p>
                <p><specList>
                    <specDesc key="entry"/>
                </specList></p>
            </div>
            <div>
                <head>Word forms</head>
                <p>There are three types of <tag>form</tag>elements: <tag>lemma</tag>, <tag>inflected</tag> and <tag>variant</tag>. Nominals are usually furnished with plural forms, verbs with the third person singular present tense.</p>
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <entry xml:lang="ar-acm-x-shawi-vicav" xml:id="DShaAr.balad_00000">
                        <form type="lemma">
                            <usg type="geographic">
                                <name type="place">Harran-Urfa</name>
                            </usg>
                            <orth>balad</orth>
                            <gramGrp>
                                <gram type="morphPattern" xml:lang="ar-acm-x-shawi-vicav">1a2a3</gram>
                            </gramGrp>
                        </form>
                        <form type="inflected">
                            <gramGrp>
                                <gram type="number">plural</gram>
                            </gramGrp>
                            <usg type="geographic">
                                <name type="place">Harran-Urfa</name>
                            </usg>
                            <orth>bələd</orth>
                        </form>
                        ...
                    </entry>
                </egXML>               
            </div>
            <div>
                <head>Grammatical Information</head>
                <p>
                    The <code>gramGrp</code> element can accomodate a wide range of grammatical information such as word class, the consonantal root and/or the verb class. It can appear in two places: when the information 
                    refers to the entry it is put after the <code>entry</code> element. In many cases, the grammatical information only refers to particular word forms. It is then placed inside the <code>form</code> element.
                </p>
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <entry xml:lang="ar-acm-x-shawi-vicav" xml:id="DShaAr.balad_00000">
                        <form type="lemma">
                            <usg type="geographic">
                                <name type="place">Harran-Urfa</name>
                            </usg>
                            <orth>balad</orth>
                            <gramGrp>
                                <gram type="morphPattern" xml:lang="ar-acm-x-shawi-vicav">1a2a3</gram>
                            </gramGrp>
                        </form>
                        <form type="inflected">
                            <gramGrp>
                                <gram type="number">plural</gram>
                            </gramGrp>
                            <usg type="geographic">
                                <name type="place">Harran-Urfa</name>
                            </usg>
                            <orth>bələd</orth>
                        </form>
                        <gramGrp>
                            <gram type="pos">noun</gram>
                            <gram type="synRoot" xml:lang="ar-acm-x-shawi-vicav">bld</gram>
                            <gram type="diaRoot" xml:lang="ar">bld</gram>
                        </gramGrp>
                        ...
                    </entry>
                </egXML>
                <div>
                    <head>Word class information</head>
                    <p>The most common POS (=part of speech) labels are listed in the following table. Most of them are self-explanatory.</p>
                    <table>
                        <row>
                            <cell>
                                <hi rend="bold">Label</hi>
                            </cell>
                            <cell>
                                <hi rend="bold">explanation</hi>
                            </cell>
                        </row>
                        <row>
                            <cell>adjective</cell>
                            <cell>Adjective</cell>
                        </row>
                        <row>
                            <cell>noun</cell>
                            <cell>Noun</cell>
                        </row>
                        <row>
                            <cell>ordinal</cell>
                            <cell>Ordinal number</cell>
                        </row>
                        <row>
                            <cell>particle</cell>
                            <cell>verb</cell>
                        </row>
                        <row>
                            <cell>pluralNoun</cell>
                            <cell>A plural noun that has an entry of its own. This does not necessarily mean that the singular does not exist, but that the plural displays semantic particularities.</cell>
                        </row>
                        <row>
                            <cell>verb</cell>
                            <cell>verb</cell>
                        </row>
                    </table>
                    
                </div>
                <div>
                    <head>Subcategorization</head>
                    <p>Certain grammatical features of word forms (<gi>gram</gi>) can be further sub-categorized. This is encoded as <gi>gram</gi> elements with <att>type</att>=<val>subc</val>. Conceptually, certain values of these gram
                        elements are tied to other gram values (e.g. <tag>gram subc="pluralNoun"</tag> implies that there is a <tag>gram type="pos"</tag> with the value "noun"). At the moment, we do not express this relation in the encoding directly, but enforce it in the Schema via schematron rules.</p>
                    <p>Possible combinations are:</p>
                    <table>
                        <row role="label">
                            <cell><val>pos</val> value</cell>
                            <cell><val>subc</val> value</cell>
                        </row>
                        <row><cell>noun</cell><cell>toponym​</cell></row>
                        <row><cell>noun</cell><cell>collectiveNoun​</cell></row>
                        <row><cell>noun</cell><cell>pluralNoun​</cell></row>
                        <row><cell>noun</cell><cell>unitNoun​</cell></row>
                        <row><cell>noun</cell><cell>diminutiveNoun​</cell></row>
                        <row><cell>numeral</cell><cell>fraction​</cell></row>
                        <row><cell>numeral</cell><cell>ordinal​</cell></row>
                    </table>
                </div>
                <div>
                    <head>Roots</head>
                    <p>Roots are indicated in accordance with etymology. Like in the generic dict schema they are encoded as a kind of grammatical properties. We distinguish between a synchronic root (<tag>synRoot</tag>) and a diachronic root (<tag>diaRoot</tag>), both of them are shown in the gramGrp:</p>
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <entry xml:lang="ar-acm-x-shawi-vicav" xml:id="DShaAr.gaad_i_000">
                            ...
                            <gramGrp>
                                <gram type="pos">noun</gram>
                                <gram type="synRoot" xml:lang="ar-acm-x-shawi-vicav">gḓy</gram>
                                <gram type="diaRoot" xml:lang="ar">qḍy</gram>
                            </gramGrp>
                            ...
                        </entry>
                    </egXML>
                    <p>Loans of the structure CāC(a) are invariably assigned CʔC.</p>
                    <table>
                        <row>
                            <cell>
                                <hi rend="bold">Word</hi>
                            </cell>
                            <cell>
                                <hi rend="bold">Root</hi>
                            </cell>
                        </row>
                        <row>
                            <cell>kār</cell>
                            <cell>kʔr</cell>
                        </row>
                    </table>
                    <p>Other loans are reduced to their consonantal skeleton.</p>
                    <p>Prepositions are dealt with in the following manner:</p>
                    <table>
                        <row>
                            <cell>
                                <hi rend="bold">Word</hi>
                            </cell>
                            <cell>
                                <hi rend="bold">Root</hi>
                            </cell>
                        </row>
                        <row>
                            <cell>bi</cell>
                            <cell>b</cell>
                        </row>
                        <row>
                            <cell>li</cell>
                            <cell>l</cell>
                        </row>
                    </table>
                </div>
                <div>
                    <head>Grammatical Gender</head>
                    <p></p>
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <entry xml:lang="ar-acm-x-shawi-vicav" xml:id="DShaAr.shamis_00000">
                            ...
                            <gramGrp>
                                <gram type="pos">noun</gram>
                                <gram type="gender">feminine</gram>
                                <gram type="synRoot" xml:lang="ar-acm-x-shawi-vicav">šms</gram>
                                <gram type="diaRoot" xml:lang="ar">šms</gram>
                            </gramGrp>
                            ...
                        </entry>
                    </egXML>
                </div>
            </div>
            <div>
                <head>Diatopic information</head>
                <p>Given the geographic distribution of the varities described in this dictionary,
                    we aim at documenting the provenance of lemmas (<tag>form type="lemma"</tag>),
                    variants (<tag>form type="variant"</tag>) and inflected forms (<tag>form
                        type="inflected"</tag>). We thus encourage using <tag>usg
                        type="geographic</tag> inside of these elements. Wherever this construct is
                    absent, the documented word form is not geographically marked.</p> 
                <p>
                    <specList>
                        <specDesc key="form"/>
                    </specList>
                </p>
            </div>
            <div>
                <head>Sources for entry parts or examples</head>
                <p>Each part of an entry can indicate the source its information is based on. In order to be able to specifically reference exact page numbers instead of whole publications, we include a <gi>listBibl</gi> at the end of each entry or example:</p>
                <egXML xmlns="http://www.tei-c.org/ns/Examples" valid="feasible">
                    <entry>
                        <form source="#d1e299557" type="lemma">
                            <orth>zarub</orth>
                        </form>
                        <!-- ... -->
                        <listBibl type="literature">
                            <bibl xml:id="d1e2995">
                                <title ref="zot:Lentin2013"/>
                                <biblScope unit="page">p.159</biblScope>
                            </bibl>
                        </listBibl>
                    </entry>
                    
                </egXML>
            </div>
            <div>
                <head>Part 2: Formal Specification</head>

                <schemaSpec ident="shawi"
                    source="https://raw.githubusercontent.com/acdh-oeaw/generic-dict-schema/main/schema/tmp/acdh-ch-dicts.compiled.odd">

                    <!-- We copy all modules from Generic dicts  -->
                    <moduleRef key="derived-module-TEILex0"/>
                    <moduleRef key="analysis"/>
                    <moduleRef key="core" except="ptr q interpretation lb mentioned"/>
                    <moduleRef key="dictionaries"/>
                    <moduleRef key="figures"/>
                    <moduleRef key="gaiji"/>
                    <moduleRef key="header"/>
                    <moduleRef key="linking"/>
                    <moduleRef key="namesdates"/>
                    <moduleRef key="tei"/>
                    <moduleRef key="textstructure"/>
                    <moduleRef key="transcr"/>
                    <moduleRef key="iso-fs"/>
                    <!-- DS ref[@type="entry"] is currently not used. -->
                    <!--  <elementSpec ident="ref" mode="change" module="core">
                        <constraintSpec ident="quote-ref" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:ref[@type='entry']">
                                    <s:assert test="parent::tei:quote">A ref type entry has to be
                                        child of quote</s:assert>
                                    <s:let name="entryIDs" value="//tei:entry/@xml:id"/>
                                    <s:assert
                                        test="some $entryID in $entryIDs satisfies $entryID = substring-after(@target, '#')"
                                        >The target attribute of a ref element in quote (<s:value-of
                                            select="@target"/>) must match the xml:id of an
                                        entry</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>-->


                    <elementSpec ident="val" mode="delete"/>
                    
                    <classSpec type="atts" ident="att.measurement" mode="delete"/>

                    <elementSpec ident="gramGrp" mode="change" module="dictionaries">
                        <content>
                            <elementRef key="model.gramPart" minOccurs="1" maxOccurs="unbounded"/>
                        </content>
                        <constraintSpec ident="gram-roots" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:gramGrp">
                                    <s:assert test="not(tei:gram[@type='synRoot']) = not(tei:gram[@type='diaRoot'])">if there is a gram type 'diaRoot', there has to be a gram type 'synRoot' in the same gramGrp, and vice versa</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>

                    <elementSpec ident="gram" mode="change" module="dictionaries">
                        <constraintSpec ident="gram-constraints" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:gram[@type = 'morphPattern']">
                                    <s:assert test="parent::tei:gramGrp/parent::tei:form[@type]">a
                                        gram type morphPattern must be a direct child of a gramGrp
                                        and a direct grandchild of a form with a type
                                        attribute</s:assert>
                                </s:rule>
                                
                                <s:rule context="tei:gram[@type = 'polarity']">
                                    <s:assert test="normalize-space(.) = 'negative'">'gram' elements with type 'polarity' can only have the value 'negative'</s:assert>
                                </s:rule>
                                <s:rule context="tei:gram[@type = 'degree']">
                                    <s:assert test="normalize-space(.) = 'elative'">'gram' elements with type 'degree' can only have the value 'elative'</s:assert>
                                </s:rule>
                                <s:rule context="tei:gram[@type = 'subc']">
                                    <s:assert test="not(normalize-space(.) = 'elative')">'gram' elements with type 'subc' can not have the value 'elative'</s:assert>
                                    <s:assert test="normalize-space(.) = ('toponym','collectiveNoun','pluralNoun','unitNoun', 'diminutiveNoun', 'fraction','ordinal​')">unexpected value "<s:value-of select="."/>" in gram[@type='subc'] is expected to be 'toponym','collectiveNoun','pluralNoun','unitNoun', 'diminutiveNoun', 'fraction','ordinal​'</s:assert>                                    
                                </s:rule>
                                <s:rule context="tei:gram[@type = 'subc'][contains(normalize-space(.),'noun')]">
                                    <s:assert test="../tei:gram[@type='pos']='noun'">gram[@type='subc'] is not expected in combination with gram[@type='pos']='<s:value-of select="../tei:gram[@type='pos']"/>' (expected: "noun")</s:assert>
                                </s:rule>
                               
                               
                                <s:rule context="tei:gram[@type = 'subc'][normalize-space(.)=('fraction','ordinal')]">
                                    <s:assert test="../tei:gram[@type='pos'] = 'numeral'">​value "<s:value-of select="."/>" is not expected in gram[@type='subc'] ​when used in combination with in​ gram[@type='pos'][. = "<s:value-of select="../tei:gram[@type='pos']"/>"]. The expected value is "numeral".</s:assert>
                                </s:rule>​
                            </constraint>
                        </constraintSpec>    
                    </elementSpec>
                    
                    
                    
                    <classSpec type="atts" ident="att.global" mode="change">
                        <attList>
                            <attDef ident="xml:lang" mode="change">
                                <valList type="closed" mode="replace">
                                    <valItem ident="ar-acm-x-shawi-vicav"/>
                                    <valItem ident="en"/>
                                    <valItem ident="de"/>
                                    <valItem ident="tr"/>
                                    <valItem ident="fr"/>
                                    <valItem ident="es"/>
                                    <valItem ident="tu"/>
                                    <valItem ident="ku"/>
                                    <valItem ident="ar"/>
                                </valList>
                            </attDef>
                        </attList>
                    </classSpec>
                    

                    <elementSpec ident="form" mode="change" module="dictionaries">
                        <constraintSpec ident="compoundOrth" scheme="schematron">
                            <constraint>
                                <s:rule
                                    context="tei:form[@type='lemma']/tei:orth[contains(., ' ') or matches(., '\w+-\w+')]">
                                    <s:assert test="parent::tei:form[@subtype = 'compound']">a form
                                        type lemma with an orth that contains a space or a hyphen
                                        (not at the beginning or end of a string) has to have a
                                        subtype compound</s:assert>
                                </s:rule>
                                <s:rule context="tei:form[@type=('lemma','variant','inflected')]">
                                    <s:assert test="tei:usg[@type='geographic']">lemmas, inflected forms and variants must inlcude usg[@type='geographic']</s:assert>
                                </s:rule>
                                <s:rule context="tei:form[@subtype='compound']">
                                    <s:assert
                                        test="tei:orth[contains(., ' ') or matches(., '\w+-\w+')]">a
                                        form with subtype compound has to have an orth child that
                                        contains a space or a hyphen (not at the beginning or end of
                                        a string)</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                        <constraintSpec ident="noType" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:form[not(@type)]">
                                    <s:assert test="parent::tei:cit[@type=('translationEquivalent','etymon')]">form elements without @type must only occur in translationEquivalents</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                        <!-- given that generic-dict-schema introduces form/@type="multiWordUnit" for backwards-compatability, we override this here according to TEI Lex-0. -->
                        <attList>
                            <attDef ident="type" mode="change" usage="opt">
                                <valList type="closed" mode="change">
                                    <valItem ident="multiWordUnit" mode="delete"/>
                                </valList>
                            </attDef>
                        </attList>
                    </elementSpec>
                    
                    <elementSpec ident="biblScope" mode="change" module="dictionaries">
                        <constraintSpec ident="biblScope-context" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:biblScope">
                                    <s:assert test="matches(., '^p\.\s?\d')">Missing or misspelled
                                        page number</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>

                    <elementSpec ident="entry" mode="change" module="dictionaries">
                        <constraintSpec ident="formSourceCheck" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:form[@source]">
                                    <s:let name="sourceIDs" value="tokenize(@source,' ')"/>
                                    <s:let name="biblID"
                                        value="following-sibling::tei:listBibl/tei:bibl/@xml:id | parent::tei:form/following-sibling::tei:listBibl/tei:bibl/@xml:id | parent::tei:form/parent::tei:form/following-sibling::tei:listBibl/tei:bibl/@xml:id"/>
                                    <s:assert
                                        test="every $sourceID in $sourceIDs satisfies substring-after($sourceID, '#') = $biblID"
                                        >If a form element has a source attribute there must be a
                                        corresponding bibl element in listBibl ("<s:value-of
                                            select="$biblID"/>")</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                       <constraintSpec ident="senseSourceCheck" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:sense[@source]">
                                    <s:let name="sourceIDs" value="tokenize(@source,' ')"/>
                                    <s:let name="biblID"
                                        value="following-sibling::tei:listBibl/tei:bibl/@xml:id"/>
                                    <s:assert
                                        test="every $sourceID in $sourceIDs satisfies substring-after($sourceID, '#') = $biblID"
                                        >If a sense element has a source attribute there must be a
                                        corresponding bibl element in listBibl ("<s:value-of
                                            select="$biblID"/>")</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>

                    <elementSpec ident="name" mode="change" module="core">
                        <constraintSpec ident="name-not-empty" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:name">
                                    <s:assert test="normalize-space(.) != ''">1: the type attribute
                                        of a name element must not be empty</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                        <attList>
                            <attDef ident="type" mode="replace" usage="req">
                                <valList type="closed">
                                    <valItem ident="place">
                                        <desc>TODO description missing</desc>
                                    </valItem>
                                    <valItem ident="tribe">
                                        <desc>TODO description missing</desc>
                                    </valItem>
                                </valList>
                            </attDef>
                        </attList>
                    </elementSpec>

                  
                </schemaSpec>
            </div>
        </body>
    </text>
</TEI>
