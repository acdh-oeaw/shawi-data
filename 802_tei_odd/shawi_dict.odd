<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml"
	schematypens="http://purl.oclc.org/dsdl/schematron"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:s="http://purl.oclc.org/dsdl/schematron">
    <teiHeader>
        <fileDesc>
            <titleStmt>
                <title>Shawi Dictionary Schema</title>
                <author><name>Charly Mörth</name></author>
                <author><name>Daniel Schopper</name></author>
                <author><name>Michaela Rausch-Supola</name></author>
                <author><name>Veronika Engler</name></author>
            </titleStmt>
            <publicationStmt>
                <publisher>Austrian Centre for Digital Humanities</publisher>
                <pubPlace>Vienna</pubPlace>
                <date>2024</date>
                <availability status="restricted">
                    <p><ref type="license" target="http://creativecommons.org/licenses/by-nc-sa/3.0/"/></p>
                </availability>
                <idno type="SHAWICorpusID">shawi.dict.odd</idno>
            </publicationStmt>
            <sourceDesc>
                <p>This ODD is a customization of TEI Lex-0, adapted for the needs of the
                    SHAWI-Project of the ACDH.</p>
            </sourceDesc>
        </fileDesc>
        <revisionDesc>
            <change status="draft" when="2024-03-01">set up ODD</change>
        </revisionDesc>
    </teiHeader>
    <text>
        <front>
            <argument>
                <p>This TEI customization fits the needs of the SHAWI-Project while conforming with
                    the baseline schema of all dictionaries created at the ACDH.</p>
            </argument>
        </front>
        <body>
            <head>SHAWI </head>
            <div>
                <head>General remarks</head>
                <p>This is the ODD for the "Shawi" dictionary, created in the project "The
                    Shawi-type Arabic dialects spoken in South-eastern Anatolia and the Middle
                    Euphrates region" (FWF P 33574), led by Stephan Próchazka (University of Vienna,
                    Department of Near Estern Studies) and Charly Mörth (Austrian Academy of
                    Sciences, Austrian Centre for Digial Humanities). In Arabic dialectology, the
                    term “Shawi-Arabic” refers to a bundle of closely related dialects spoken by
                        Šawāya<note place="bottom">
                        <p>The term Šawāya is an exonym and sometimes even regarded as mildly
                            pejorative by the so named people themselves. Thus, in this application,
                            the term is understood in a purely areal linguistic sense (see next
                            paragraph) as it has been well-established in Arabic dialectology for
                            many decades  (cf. Behnstedt 2000:424, Herin &amp; Younes 2019, Jastrow
                            1997, Lentin 2013:152-155).</p>
                    </note> (plural of Šāwī), sheep and goat herding semi-nomadic tribes in various
                    regions of the Fertile Crescent, esp. Syria, Turkey, northern Lebanon, northern
                    Israel, and Jordan.</p>
                <p>The dictionary is a customization of <ref
                        target="https://dariah-eric.github.io/lexicalresources/pages/TEILex0/TEILex0.html"
                        >TEI Lex-0</ref> through the <ref
                        target="https://github.com/acdh-oeaw/generic-dict-schema/">ACDH generic dict
                        schema</ref> which defines a framework for dictionaries created at the ACDH,
                    namely the ones to be created in the context of VICAV - the Vienna Corpus of
                    Arabic Varieties. Please refer to the ODD of the generic dict schema for more
                    information. This ODD describes and documents where the Shawi dictionary differs
                    from this schema.</p>
            </div>
            <div>
                <head>Dictionary entries</head>
                <p>Entries in the Shawi dictionary follow the Lex-0 model. Accordingly, dictionary entries describing
                    multi-word-units are encoded as <tag>entry type="main" subtype="compound"</tag> (see <ref target="https://dariah-eric.github.io/lexicalresources/pages/TEILex0/TEILex0.html#index.xml-body.1_div.4_div.6">Section 4.6. Multiword expressions</ref>).</p>
                <p>The <name>generic dict schema</name> introduces <tag>entry
                    type="multiWordUnit</tag> for encoding MWUs in order to ensure backwards compatability with the legacy encoding of VICAV dictionaries. Since the Shawi
                    dictionary should follow TEI Lex-0 more closely, this is overridden in the Shawi Dictionary ODD again. We relocate the distinction onto the <tag>form</tag> level.</p>
                <p><specList>
                    <specDesc key="entry"/>
                </specList></p>
            </div>
            <div>
                <head>Word forms</head>
                <p>There are three types of <tag>form</tag>elements: <val>lemma</val>, <val>inflected</val> and <val>variant</val>, whereas variants occur as children of the two other types. Nominals are usually furnished with plural forms, verbs with the third person singular present tense.</p>
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <entry xml:lang="ar-acm-x-shawi-vicav" xml:id="DShaAr.baqal_000">
                        <form type="lemma">
                            <usg type="geographic">
                                <name type="place">Harran-Urfa</name>
                            </usg>
                            <orth>baqaḷ</orth>
                            <gramGrp>
                                <gram type="morphPattern" xml:lang="ar-acm-x-shawi-vicav">1a23</gram>
                            </gramGrp>
                            <form type="variant">
                                <usg type="geographic">
                                    <name type="place">Bekaa</name>
                                    <name type="tribe">Idin</name>
                                </usg>
                                <orth>ḅaġaḷ</orth>
                            </form>
                        </form>
                        <form type="inflected">
                            <gramGrp>
                                <gram type="number">singular</gram>
                                <gram type="gender">feminine</gram>
                            </gramGrp>
                            <usg type="geographic">
                                <name type="place">Harran-Urfa</name>
                            </usg>
                            <orth>bqaḷa</orth>
                            <form type="variant">
                                <usg type="geographic">
                                    <name type="place">Bekaa</name>
                                    <name type="tribe">Idin</name>
                                </usg>
                                <orth>ḅġaḷa</orth>
                            </form>
                        </form>
                        ...
                    </entry>
                </egXML>
                <p>In case of derivation, each derived form is an entry in its own right. Both entries are interlinked via <gi>xr</gi> elements (note that the values <val>hasDerivedForm</val> and <val>isDerivedFormOf</val> need to be defined in the dictionary's <gi>teiHeader</gi>.</p>
                <egXML xmlns="http://www.tei-c.org/ns/Examples" valid="feasible">
                    
                    <entry xml:id="DShaAr.bsala_00000">
                        <form type="lemma">
                            <orth>bṣala</orth>
                        </form>
                        <xr type="related" ana="#isDerivedFormOf">
                            <ref type="entry" target="#DShaAr.besal_00000"/>
                        </xr>
                        <gramGrp>
                            <gram type="pos">unitNoun</gram>
                        </gramGrp>
                    </entry>
                    <entry xml:id="DShaAr.besal_00000">
                        <form type="lemma">
                            <orth>bəṣal</orth>
                        </form>
                        <xr type="related" ana="#hasDerivedForm">
                            <ref type="entry" target="#DShaAr.bsala_00000"/>
                        </xr>
                    </entry>
                </egXML>
            </div>
            <div>
                <head>Grammatical information</head>
                <p>
                    The <code>gramGrp</code> element can accomodate a wide range of grammatical information such as word class, the consonantal root and/or the verb class. It can appear in two places: when the information 
                    refers to the entry it is put after the <code>entry</code> element. In many cases, the grammatical information only refers to particular word forms. It is then placed inside the <code>form</code> element.
                </p>
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <entry xml:lang="ar-acm-x-shawi-vicav" xml:id="DShaAr.balad_00000">
                        <form type="lemma">
                            <usg type="geographic">
                                <name type="place">Harran-Urfa</name>
                            </usg>
                            <orth>balad</orth>
                            <gramGrp>
                                <gram type="morphPattern" xml:lang="ar-acm-x-shawi-vicav">1a2a3</gram>
                            </gramGrp>
                        </form>
                        <form type="inflected">
                            <gramGrp>
                                <gram type="number">plural</gram>
                            </gramGrp>
                            <usg type="geographic">
                                <name type="place">Harran-Urfa</name>
                            </usg>
                            <orth>bələd</orth>
                        </form>
                        <gramGrp>
                            <gram type="pos">noun</gram>
                            <gram type="synRoot" xml:lang="ar-acm-x-shawi-vicav">bld</gram>
                            <gram type="diaRoot" xml:lang="ar">bld</gram>
                        </gramGrp>
                        ...
                    </entry>
                </egXML>
                <div>
                    <head>Word class information</head>
                    <p>The most common POS (=part of speech) labels are listed in the following table. Most of them are self-explanatory.</p>
                    <table>
                        <row>
                            <cell>
                                <hi rend="bold">Label</hi>
                            </cell>
                            <cell>
                                <hi rend="bold">explanation</hi>
                            </cell>
                        </row>
                        <row>
                            <cell>adjective</cell>
                            <cell>Adjective</cell>
                        </row>
                        <row>
                            <cell>noun</cell>
                            <cell>Noun</cell>
                        </row>
                        <row>
                            <cell>ordinal</cell>
                            <cell>Ordinal number</cell>
                        </row>
                        <row>
                            <cell>particle</cell>
                            <cell>verb</cell>
                        </row>
                        <row>
                            <cell>pluralNoun</cell>
                            <cell>A plural noun that has an entry of its own. This does not necessarily mean that the singular does not exist, but that the plural displays semantic particularities.</cell>
                        </row>
                        <row>
                            <cell>verb</cell>
                            <cell>verb</cell>
                        </row>
                    </table>
                    
                </div>
                <div>
                    <head>Subcategorization</head>
                    <p>Certain grammatical features of word forms (<gi>gram</gi>) can be further sub-categorized. This is encoded as <gi>gram</gi> elements with <att>type</att>=<val>subc</val>. Conceptually, certain values of these gram
                        elements are tied to other gram values (e.g. <tag>gram subc="pluralNoun"</tag> implies that there is a <tag>gram type="pos"</tag> with the value "noun"). At the moment, we do not express this relation in the encoding directly, but enforce it in the Schema via schematron rules.</p>
                    <p>Possible combinations are:</p>
                    <table>
                        <row role="label">
                            <cell><val>pos</val> value</cell>
                            <cell><val>subc</val> value</cell>
                        </row>
                        <row><cell>noun</cell><cell>toponym​</cell></row>
                        <row><cell>noun</cell><cell>collectiveNoun​</cell></row>
                        <row><cell>noun</cell><cell>pluralNoun​</cell></row>
                        <row><cell>noun</cell><cell>unitNoun​</cell></row>
                        <row><cell>noun</cell><cell>diminutiveNoun​</cell></row>
                        <row><cell>numeral</cell><cell>fraction​</cell></row>
                        <row><cell>numeral</cell><cell>ordinal​</cell></row>
                    </table>
                </div>
                <div>
                    <head>Roots</head>
                    <p>Roots are indicated in accordance with etymology. Like in the generic dict schema they are encoded as a kind of grammatical properties. We distinguish between a synchronic root (<tag>synRoot</tag>) and a diachronic root (<tag>diaRoot</tag>), both of them are shown in the gramGrp:</p>
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <entry xml:lang="ar-acm-x-shawi-vicav" xml:id="DShaAr.gaad_i_000">
                            ...
                            <gramGrp>
                                <gram type="pos">noun</gram>
                                <gram type="synRoot" xml:lang="ar-acm-x-shawi-vicav">gḓy</gram>
                                <gram type="diaRoot" xml:lang="ar">qḍy</gram>
                            </gramGrp>
                            ...
                        </entry>
                    </egXML>
                    <p>Loans of the structure CāC(a) are invariably assigned CʔC.</p>
                    <table>
                        <row>
                            <cell>
                                <hi rend="bold">Word</hi>
                            </cell>
                            <cell>
                                <hi rend="bold">Root</hi>
                            </cell>
                        </row>
                        <row>
                            <cell>kār</cell>
                            <cell>kʔr</cell>
                        </row>
                    </table>
                    <p>Other loans are reduced to their consonantal skeleton.</p>
                    <p>Prepositions are dealt with in the following manner:</p>
                    <table>
                        <row>
                            <cell>
                                <hi rend="bold">Word</hi>
                            </cell>
                            <cell>
                                <hi rend="bold">Root</hi>
                            </cell>
                        </row>
                        <row>
                            <cell>bi</cell>
                            <cell>b</cell>
                        </row>
                        <row>
                            <cell>li</cell>
                            <cell>l</cell>
                        </row>
                    </table>
                </div>
                <div>
                    <head>Grammatical gender</head>
                    <p></p>
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <entry xml:lang="ar-acm-x-shawi-vicav" xml:id="DShaAr.shamis_00000">
                            ...
                            <gramGrp>
                                <gram type="pos">noun</gram>
                                <gram type="gender">feminine</gram>
                                <gram type="synRoot" xml:lang="ar-acm-x-shawi-vicav">šms</gram>
                                <gram type="diaRoot" xml:lang="ar">šms</gram>
                            </gramGrp>
                            ...
                        </entry>
                    </egXML>
                </div>
                <div>
                    <head>Elatives</head>
                    <p>Elatives should be registered under the respective positive forms. In some cases it may make sense to treat a particular elative as a lexeme in its own right.</p>
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <entry xml:lang="ar-acm-x-shawi-vicav" xml:id="DShaAr.makruuh_00000">
                            <form type="lemma">
                                <usg type="geographic">
                                    <name type="place">Harran-Urfa</name>
                                </usg>
                                <orth>makrūh</orth>
                                <gramGrp>
                                    <gram type="morphPattern" xml:lang="ar-acm-x-shawi-vicav">ma12ū3</gram>
                                </gramGrp>
                            </form>
                            <form source="#d1e125648" type="inflected">
                                <gramGrp>
                                    <gram type="aspect">elative</gram>
                                </gramGrp>
                            </form>
                            ...
                        </entry>
                    </egXML>
                </div>
                <div>
                    <head>Invariable nouns and adjectives</head>
                    <p>Many Arabic dialects have nominals which do not display feminine or plural forms. These are identified with a gram element and a morphType attribute.</p>
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        ...
                        <gramGrp>
                            <gram type="pos">adjective</gram>
                            <gram type="subc">invariable</gram>
                            <gram type="synRoot" xml:lang="ar-acm-x-shawi-vicav">ʕǧb</gram>
                            <gram type="diaRoot" xml:lang="ar">ʕǧb</gram>
                        </gramGrp>
                        ...
                    </egXML>
                </div>
                <div>
                    <head>Participles</head>
                    <p></p>
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        ...
                        <gramGrp>
                            <gram type="aspect">passiveParticiple</gram>
                            <gram type="number">singular</gram>
                            <gram type="person">masculine</gram>
                        </gramGrp>
                        ...
                    </egXML>
                </div>
                <div>
                    <head>Functional constraints</head>
                    <p>Another option are usage labels which can be used to indicate functional constraints.</p>
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                            ...
                            <sense xml:id="DShaAr.s_hu_000_0">
                                <gramGrp>
                                    <gram type="usg">only in phrases taken from Classical Arabic</gram>
                                </gramGrp>
                                ...
                            </sense>
                            ...
                    </egXML>
                </div>
            </div>
            <div>
                <head>Translations</head>
                <div>
                    <head>Translating lemmas</head>
                    <p>Translations of lemmas (incl. compounds) are given in <tag>sense</tag> elements with a <tag>cit</tag> of the type <tag>translationEquivalent</tag>.</p>
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <entry xml:lang="ar-acm-x-shawi-vicav" xml:id="DShaAr.hama_00001">
                            ...
                            <sense xml:id="DShaAr.s__00001_0">
                                <cit type="translationEquivalent" xml:lang="en">
                                    <form>
                                        <orth>to become hot</orth>
                                    </form>
                                </cit>
                                <cit type="translationEquivalent" xml:lang="de">
                                    <form>
                                        <orth>sich erhitzen</orth>
                                    </form>
                                </cit>
                                <cit type="translationEquivalent" xml:lang="de">
                                    <form>
                                        <orth>heiß werden</orth>
                                    </form>
                                </cit>
                            ...
                            </sense>
                            ...
                        </entry>
                    </egXML>
                    <p>Semantically unrelated homophones or items with clearly differing semantics have to be documented with several sense elements.</p>
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        ...
                        <sense xml:id="DShaAr.s_xafiif_00000_0">
                            <cit type="translationEquivalent" xml:lang="en">
                                <form>
                                    <orth>light</orth>
                                </form>
                            </cit>
                            <cit type="translationEquivalent" xml:lang="de">
                                <form>
                                    <orth>leicht (Gewicht)</orth>
                                </form>
                            </cit>
                            ...
                        </sense>
                        <sense xml:id="DShaAr.s_xafiif_00000_1">
                            <cit source="#d1e242058" type="translationEquivalent" xml:lang="en">
                                <form>
                                    <orth>easy</orth>
                                </form>
                            </cit>
                            <cit type="translationEquivalent" xml:lang="de">
                                <form>
                                    <orth>einfach</orth>
                                </form>
                            </cit>
                            ...
                        </sense>
                        ...
                    </egXML>
                </div>
                <div>
                    <head>Translating examples</head>
                    <p>Translations of examples are indicated in <tag>cit/quote</tag> constructions with the type <tag>translation</tag> for <tag>cit</tag>.</p>
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <cit type="example" xml:id="DShaAr.id_302">
                            <quote>āni b-al-baʕīr saraḥit čiṯīr.</quote>
                            <cit type="translation" xml:lang="en">
                                <quote>I often grazed the camels.</quote>
                            </cit>
                            <cit type="translation" xml:lang="de">
                                <quote>Ich führte die Kamele oft auf die Weide.</quote>
                            </cit>
                            ...
                        </cit>
                    </egXML>
                </div>
                <div>
                    <head>Definitions</head>
                    <p>When the translation of a term is not very common or easily understandable in the target language, it is common practise to explain the item instead of or in addition to the translation. Explanations can be understood as same language ‛translations’. In TEI, the <tag>def</tag> “definition” element is used to encode this part of a dictionary entry.</p>
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <sense xml:id="DShaAr.s_shugbaan_000_0">
                            <def xml:lang="en">a kind of pouch on the belly that is formed by pulling up the dress</def>
                            <cit type="translationEquivalent" xml:lang="en">
                                <form>
                                    <orth>shugban</orth>
                                </form>
                            </cit>
                            <def xml:lang="de">eine Art Schürze, die man durch Hochheben des Kleides bildet</def>
                            <cit type="translationEquivalent" xml:lang="de">
                                <form>
                                    <orth>Schugban</orth>
                                </form>
                            </cit>
                            ...
                         </sense>
                    </egXML>
                    <p>
                        Very often lexical items are particular to the culture of the source language and do not have adequate equivalents in a target language. In such cases, it is important not to enter definitions or explanations in the <tag>cit/quote</tag> element. Wherever possible, we have tried to furnish translations (very often transliterations) even though they might not be very common in the target language. Explanations have to go into the <tag>def</tag> element.
                        In principle, <tag>def</tag> can be used to encode any information related to ‛meaning’ that does not qualify as a translation in the narrower sense.
                    </p>
                </div>
                <div>
                    <head>Names</head>
                    <p>How to write/transliterate place names and person names is an age-old problem. When several graphematic variants exist, we attempt to choose the most common one.</p>
                    <!-- example missing -->
                </div>
            </div>
            <div>
                <head>Diatopic information</head>
                <p>Given the geographic distribution of the varities described in this dictionary,
                    we aim at documenting the provenance of lemmas (<tag>form type="lemma"</tag>),
                    variants (<tag>form type="variant"</tag>) and inflected forms (<tag>form
                        type="inflected"</tag>). We thus encourage using <tag>usg
                        type="geographic</tag> inside of these elements. Wherever this construct is
                    absent, the documented word form is not geographically marked.</p> 
                <p>
                    <specList>
                        <specDesc key="form"/>
                    </specList>
                </p>
            </div>
            <div>
                <head>Sources for entry parts or examples</head>
                <p>Each part of an entry can indicate the source its information is based on. In order to be able to specifically reference exact page numbers instead of whole publications, we include a <gi>listBibl</gi> at the end of each entry or example:</p>
                <egXML xmlns="http://www.tei-c.org/ns/Examples" valid="feasible">
                    <entry>
                        <form source="#d1e299557" type="lemma">
                            <orth>zarub</orth>
                        </form>
                        <!-- ... -->
                        <listBibl type="literature">
                            <bibl xml:id="d1e2995">
                                <title ref="zot:Lentin2013"/>
                                <biblScope unit="page">p.159</biblScope>
                            </bibl>
                        </listBibl>
                    </entry>
                    
                </egXML>
            </div>
            <div>
                <head>Part 2: Formal Specification</head>

                <schemaSpec ident="shawi"
                    source="https://raw.githubusercontent.com/acdh-oeaw/generic-dict-schema/main/schema/tmp/acdh-ch-dicts.compiled.odd">

                    <!-- We copy all modules from Generic dicts  -->
                    <moduleRef key="derived-module-TEILex0"/>
                    <moduleRef key="analysis"/>
                    <moduleRef key="core" except="ptr q interpretation lb mentioned"/>
                    <moduleRef key="dictionaries"/>
                    <moduleRef key="figures"/>
                    <moduleRef key="gaiji"/>
                    <moduleRef key="header"/>
                    <moduleRef key="linking"/>
                    <moduleRef key="namesdates"/>
                    <moduleRef key="tei"/>
                    <moduleRef key="textstructure"/>
                    <moduleRef key="transcr"/>
                    <moduleRef key="iso-fs"/>
                    <!-- DS ref[@type="entry"] is currently not used. -->
                    <!--  <elementSpec ident="ref" mode="change" module="core">
                        <constraintSpec ident="quote-ref" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:ref[@type='entry']">
                                    <s:assert test="parent::tei:quote">A ref type entry has to be
                                        child of quote</s:assert>
                                    <s:let name="entryIDs" value="//tei:entry/@xml:id"/>
                                    <s:assert
                                        test="some $entryID in $entryIDs satisfies $entryID = substring-after(@target, '#')"
                                        >The target attribute of a ref element in quote (<s:value-of
                                            select="@target"/>) must match the xml:id of an
                                        entry</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>-->


                    <elementSpec ident="val" mode="delete"/>
                    
                    <classSpec type="atts" ident="att.measurement" mode="delete"/>

                    <elementSpec ident="gramGrp" mode="change" module="dictionaries">
                        <content>
                            <elementRef key="model.gramPart" minOccurs="1" maxOccurs="unbounded"/>
                        </content>
                        <constraintSpec ident="gramGrpChildrenOrder" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:gramGrp">
                                    <s:assert test="count(tei:gram[@type='arguments']) &lt; 2 or not(tei:gram[@type='arguments'][1]/following-sibling::*[not(self::tei:gram[@type='arguments'])]/following-sibling::tei:gram[@type='arguments'])">All gramGrp elements with type arguments must occur consecutively without any other elements between them.</s:assert>
                                    <s:assert test="count(tei:gram[@type='diaRoot']) &lt; 2 or not(tei:gram[@type='diaRoot'][1]/following-sibling::*[not(self::tei:gram[@type='diaRoot'])]/following-sibling::tei:gram[@type='diaRoot'])">All gramGrp elements with type diaRoot must occur consecutively without any other elements between them.</s:assert>
                                    <s:assert test="count(tei:gram[@type='morphPattern']) &lt; 2 or not(tei:gram[@type='morphPattern'][1]/following-sibling::*[not(self::tei:gram[@type='morphPattern'])]/following-sibling::tei:gram[@type='morphPattern'])">All gramGrp elements with type morphPattern must occur consecutively without any other elements between them.</s:assert>
                                    <s:assert test="count(tei:gram[@type='pos']) &lt; 2 or not(tei:gram[@type='pos'][1]/following-sibling::*[not(self::tei:gram[@type='pos'])]/following-sibling::tei:gram[@type='pos'])">All gramGrp elements with type pos must occur consecutively without any other elements between them.</s:assert>
                                    <s:assert test="count(tei:gram[@type='synRoot']) &lt; 2 or not(tei:gram[@type='synRoot'][1]/following-sibling::*[not(self::tei:gram[@type='synRoot'])]/following-sibling::tei:gram[@type='synRoot'])">All gramGrp elements with type synRoot must occur consecutively without any other elements between them.</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>

                    <elementSpec ident="gram" mode="change" module="dictionaries">
                        <constraintSpec ident="gram-constraints" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:gram[@type = 'morphPattern']">
                                    <s:assert test="parent::tei:gramGrp/parent::tei:form[@type]">a
                                        gram type morphPattern must be a direct child of a gramGrp
                                        and a direct grandchild of a form with a type
                                        attribute</s:assert>
                                </s:rule>
                                
                                <s:rule context="tei:gram[@type = 'polarity']">
                                    <s:assert test="normalize-space(.) = 'negative'">'gram' elements with type 'polarity' can only have the value 'negative'</s:assert>
                                </s:rule>
                                <s:rule context="tei:gram[@type = 'degree']">
                                    <s:assert test="normalize-space(.) = 'elative'">'gram' elements with type 'degree' can only have the value 'elative'</s:assert>
                                </s:rule>
                                <s:rule context="tei:gram[@type = 'subc']">
                                    <s:assert test="not(normalize-space(.) = 'elative')">'gram' elements with type 'subc' can not have the value 'elative'</s:assert>
                                    <s:assert test="normalize-space(.) = ('toponym','collectiveNoun','pluralNoun','unitNoun', 'diminutiveNoun', 'fraction','ordinal​')">unexpected value "<s:value-of select="."/>" in gram[@type='subc'] is expected to be 'toponym','collectiveNoun','pluralNoun','unitNoun', 'diminutiveNoun', 'fraction','ordinal​'</s:assert>                                    
                                </s:rule>
                                <s:rule context="tei:gram[@type = 'subc'][contains(normalize-space(.),'noun')]">
                                    <s:assert test="../tei:gram[@type='pos']='noun'">gram[@type='subc'] is not expected in combination with gram[@type='pos']='<s:value-of select="../tei:gram[@type='pos']"/>' (expected: "noun")</s:assert>
                                </s:rule>
                                <s:rule context="tei:gram[@type = 'subc'][normalize-space(.)=('fraction','ordinal')]">
                                    <s:assert test="../tei:gram[@type='pos'] = 'numeral'">​value "<s:value-of select="."/>" is not expected in gram[@type='subc'] ​when used in combination with in​ gram[@type='pos'][. = "<s:value-of select="../tei:gram[@type='pos']"/>"]. The expected value is "numeral".</s:assert>
                                </s:rule>​
                            </constraint>
                        </constraintSpec>    
                    </elementSpec>
                    
                    
                    <classSpec type="atts" ident="att.global" mode="change">
                        <constraintSpec ident="xml-lang-on-object-lang-elts" scheme="schematron" mode="change" xml:id="xml-lang-on-object-lang-elts">
                            <desc>assert that @xml:lang is added to elements with object language</desc>
                            <constraint>
                                <s:rule
                                    context="tei:entry|tei:gram[@type=('arguments','collocate','diaRoot','government','morphPattern','synRoot')]|tei:orth|tei:quote">
                                    <s:assert test="exists(@xml:lang)">Elements containing object language must have an @xml:lang attribute.</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                        <attList>
                            <attDef ident="xml:lang" mode="change">
                                <valList type="closed" mode="replace">
                                    <valItem ident="ar-acm-x-shawi-vicav"/>
                                    <valItem ident="ar-Latn"/>
                                    <valItem ident="en"/>
                                    <valItem ident="de"/>
                                    <valItem ident="tr"/>
                                    <valItem ident="fr"/>
                                    <valItem ident="es"/>
                                    <valItem ident="tu"/>
                                    <valItem ident="ku"/>
                                    <valItem ident="ar"/>
                                </valList>
                            </attDef>
                        </attList>
                    </classSpec>
                    

                    <elementSpec ident="form" mode="change" module="dictionaries">
                        <constraintSpec ident="compoundOrth" scheme="schematron">
                            <constraint>
                                <s:rule
                                    context="tei:form[@type='lemma']/tei:orth[contains(., ' ') or matches(., '\w+-\w+')]">
                                    <s:assert test="parent::tei:form[@subtype = 'compound']">a form
                                        type lemma with an orth that contains a space or a hyphen
                                        (not at the beginning or end of a string) has to have a
                                        subtype compound</s:assert>
                                </s:rule>
                                <s:rule context="tei:form[@subtype='compound']">
                                    <s:assert
                                        test="tei:orth[contains(., ' ') or matches(., '\w+-\w+')]">a
                                        form with subtype compound has to have an orth child that
                                        contains a space or a hyphen (not at the beginning or end of
                                        a string)</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                        <constraintSpec ident="noType" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:form[not(@type)]">
                                    <s:assert test="parent::tei:cit[@type=('translationEquivalent','etymon')]">form elements without @type must only occur in translationEquivalents</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                        <constraintSpec ident="formChildrenOrder" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:form">
                                    <s:assert test="count(tei:form[@type='inflected']) &lt; 2 or not(tei:form[@type='inflected'][1]/following-sibling::*[not(self::tei:form[@type='inflected'])]/following-sibling::tei:form[@type='inflected'])">All inflected forms in form must occur consecutively without any other elements between them.</s:assert>
                                    <s:assert test="count(tei:form[@type='variant']) &lt; 2 or not(tei:form[@type='variant'][1]/following-sibling::*[not(self::tei:form[@type='variant'])]/following-sibling::tei:form[@type='variant'])">All variational forms must occur consecutively without any other elements between them.</s:assert>
                                    <s:assert test="count(tei:usg[@type='geographic']) &lt; 2 or not(tei:usg[@type='geographic'][1]/following-sibling::*[not(self::tei:usg[@type='geographic'])]/following-sibling::tei:usg[@type='geographic'])">All usg elements with type geographic must occur consecutively without any other elements between them.</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                        <!-- given that generic-dict-schema introduces form/@type="multiWordUnit" for backwards-compatability, we override this here according to TEI Lex-0. -->
                        <attList>
                            <attDef ident="type" mode="change" usage="opt">
                                <valList type="closed" mode="change">
                                    <valItem ident="multiWordUnit" mode="delete"/>
                                </valList>
                            </attDef>
                        </attList>
                    </elementSpec>
                    
                    <elementSpec ident="listBibl" mode="change" module="core">
                        <constraintSpec ident="literatureCheck" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:bibl/tei:title[@ref='zot:Bettini2006']">
                                    <s:assert test="number(substring-after(./following-sibling::tei:biblScope, 'p.')) &gt; 358
                                        and
                                        number(substring-after(./following-sibling::tei:biblScope, 'p.')) &lt; 399">If Bettini2006 is the source, the following biblScope pages must be between 359 and 398.</s:assert>
                                </s:rule>
                                <s:rule context="tei:bibl/tei:title[@ref='zot:Lentin2013']">
                                    <s:assert test="number(substring-after(./following-sibling::tei:biblScope, 'p.')) &gt; 150
                                        and
                                        number(substring-after(./following-sibling::tei:biblScope, 'p.')) &lt; 172">If Lentin2013 is the source, the following biblScope pages must be between 151 and 171.</s:assert>
                                </s:rule>
                                <s:rule context="tei:bibl/tei:title[@ref='zot:Younes2021']">
                                    <s:assert test="number(substring-after(./following-sibling::tei:biblScope, 'p.')) &gt; 0
                                        and
                                        number(substring-after(./following-sibling::tei:biblScope, 'p.')) &lt; 137">If Younes2021 is the source, the following biblScope pages must be between 1 and 136.</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>
                    
                    <elementSpec ident="biblScope" mode="change" module="dictionaries">
                        <constraintSpec ident="biblScope-context" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:biblScope">
                                    <s:assert test="matches(., '^p\.\s?\d')">Missing or misspelled page number</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>

                    <elementSpec ident="usg" mode="change" module="dictionaries">
                        <constraintSpec ident="usgChildrenOrder" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:usg">
                                    <s:assert test="count(tei:name[@type='place']) &lt; 2 or not(tei:name[@type='place'][1]/following-sibling::*[not(self::tei:name[@type='place'])]/following-sibling::tei:name[@type='place'])">All name elements with type place must occur consecutively without any other elements between them.</s:assert>
                                    <s:assert test="count(tei:name[@type='tribe']) &lt; 2 or not(tei:name[@type='tribe'][1]/following-sibling::*[not(self::tei:name[@type='tribe'])]/following-sibling::tei:name[@type='tribe'])">All name elements with type tribe must occur consecutively without any other elements between them.</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>
                    
                    <elementSpec ident="etym" mode="change" module="dictionaries">
                        <constraintSpec ident="etymChildrenOrder" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:etym">
                                    <s:assert test="count(tei:cit[@type='etymon']) &lt; 2 or not(tei:cit[@type='etymon'][1]/following-sibling::*[not(self::tei:cit[@type='etymon'])]/following-sibling::tei:cit[@type='etymon'])">All cit elements with type etymon must occur consecutively without any other elements between them.</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>
                    
                    <elementSpec ident="cit" mode="change" module="core">
                        <constraintSpec ident="citChildrenOrder" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:cit">
                                    <s:assert test="count(tei:cit[@type='translation']) &lt; 2 or not(tei:cit[@type='translation'][1]/following-sibling::*[not(self::tei:cit[@type='translation'])]/following-sibling::tei:cit[@type='translation'])">All cit elements with type translation must occur consecutively without any other elements between them.</s:assert>
                                    <s:assert test="count(tei:fs[@type='change']) &lt; 2 or not(tei:fs[@type='change'][1]/following-sibling::*[not(self::tei:fs[@type='change'])]/following-sibling::tei:fs[@type='change'])">All fs elements with type change must occur consecutively without any other elements between them.</s:assert>
                                    <s:assert test="count(tei:usg[@type='geographic']) &lt; 2 or not(tei:usg[@type='geographic'][1]/following-sibling::*[not(self::tei:usg[@type='geographic'])]/following-sibling::tei:usg[@type='geographic'])">All usg elements with type geographic must occur consecutively without any other elements between them.</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>
                    
                    <elementSpec ident="sense" mode="change" module="dictionaries">
                        <constraintSpec ident="senseChildrenOrder" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:sense">
                                    <s:assert test="count(tei:cit[@type='translationEquivalent']) &lt; 2 or not(tei:cit[@type='translationEquivalent'][1]/following-sibling::*[not(self::tei:cit[@type='translationEquivalent'])]/following-sibling::tei:cit[@type='translationEquivalent'])">All cit elements with type translationEquivalent must occur consecutively without any other elements between them.</s:assert>
                                    <s:assert test="count(tei:ref[@type='example']) &lt; 2 or not(tei:ref[@type='example'][1]/following-sibling::*[not(self::tei:ref[@type='example'])]/following-sibling::tei:ref[@type='example'])">All ref elements with type example must occur consecutively without any other elements between them.</s:assert>
                                    <s:assert test="count(tei:usg[@type='geographic']) &lt; 2 or not(tei:usg[@type='geographic'][1]/following-sibling::*[not(self::tei:usg[@type='geographic'])]/following-sibling::tei:usg[@type='geographic'])">All usg elements with type geographic must occur consecutively without any other elements between them.</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>

                    <elementSpec ident="entry" mode="change" module="dictionaries">
                        <constraintSpec ident="entryChildrenOrder" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:entry">
                                    <s:assert test="count(tei:form[@type='lemma']) = 1">there is only one form type lemma allowed in entry</s:assert>
                                    <s:assert test="count(tei:form[@type='inflected']) &lt; 2 or not(tei:form[@type='inflected'][1]/following-sibling::*[not(self::tei:form[@type='inflected'])]/following-sibling::tei:form[@type='inflected'])">All inflected forms in entry must occur consecutively without any other elements between them.</s:assert>
                                    <s:assert test="count(tei:fs[@type='change']) &lt; 2 or not(tei:fs[@type='change'][1]/following-sibling::*[not(self::tei:fs[@type='change'])]/following-sibling::tei:fs[@type='change'])">All fs elements with type change must occur consecutively without any other elements between them.</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                        <constraintSpec ident="formSourceCheck" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:form[@source]">
                                    <s:let name="sourceIDs" value="tokenize(@source,' ')"/>
                                    <s:let name="biblID"
                                        value="following-sibling::tei:listBibl/tei:bibl/@xml:id | parent::tei:form/following-sibling::tei:listBibl/tei:bibl/@xml:id | parent::tei:form/parent::tei:form/following-sibling::tei:listBibl/tei:bibl/@xml:id"/>
                                    <s:assert
                                        test="every $sourceID in $sourceIDs satisfies substring-after($sourceID, '#') = $biblID"
                                        >If a form element has a source attribute there must be a
                                        corresponding bibl element in listBibl ("<s:value-of
                                            select="$biblID"/>")</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                       <constraintSpec ident="senseSourceCheck" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:sense[@source]">
                                    <s:let name="sourceIDs" value="tokenize(@source,' ')"/>
                                    <s:let name="biblID"
                                        value="following-sibling::tei:listBibl/tei:bibl/@xml:id"/>
                                    <s:assert
                                        test="every $sourceID in $sourceIDs satisfies substring-after($sourceID, '#') = $biblID"
                                        >If a sense element has a source attribute there must be a
                                        corresponding bibl element in listBibl ("<s:value-of
                                            select="$biblID"/>")</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                        <constraintSpec ident="biblPlaceCheck" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:form">
                                    <s:assert test="
                                        every $sourceID in tokenize(@source,' ') satisfies
                                        let $bibl :=
                                            ancestor::tei:entry//tei:bibl[@xml:id = substring-after($sourceID, '#')],
                                                $zot := substring-after($bibl/tei:title/@ref, 'zot:'),
                                                $place := tei:usg[@type='geographic']/tei:name[@type='place']
                                        return
                                            (
                                                ($zot = 'Lentin2013' and $place = 'Mayadin')
                                                or ($zot = 'Younes2021' and $place = 'Bekaa')
                                                or ($zot = 'Bettini2006' and ($place = 'Jbur' or $place = 'Tayy'))
                                                or not ($zot = ('Lentin2013', 'Younes2021', 'Bettini2006'))
                                             )
                                             ">Invalid geographic usage for <s:value-of select="tokenize(@source,' ')"/>
                                    </s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>
                    
                    <elementSpec ident="fs" mode="change" module="iso-fs">
                        <constraintSpec ident="hasStatusCheck" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:entry/tei:fs">
                                    <s:assert test="tei:f[@name='status']/tei:symbol/@value = ('stub', 'draft', 'released')">at least one f with name status must exist and its child must have one of the values 'stub', 'draft' or 'released'</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                    </elementSpec>

                    <elementSpec ident="name" mode="change" module="core">
                        <constraintSpec ident="name-not-empty" scheme="schematron">
                            <constraint>
                                <s:rule context="tei:name">
                                    <s:assert test="normalize-space(.) != ''">1: the type attribute
                                        of a name element must not be empty</s:assert>
                                </s:rule>
                            </constraint>
                        </constraintSpec>
                        <attList>
                            <attDef ident="type" mode="replace" usage="req">
                                <valList type="closed">
                                    <valItem ident="place">
                                        <desc>TODO description missing</desc>
                                    </valItem>
                                    <valItem ident="tribe">
                                        <desc>TODO description missing</desc>
                                    </valItem>
                                </valList>
                            </attDef>
                        </attList>
                    </elementSpec>

                  
                </schemaSpec>
            </div>
        </body>
    </text>
</TEI>
